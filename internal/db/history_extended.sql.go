// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: history_extended.sql

package db

import (
	"context"
	"database/sql"
)

const ClearFavoriteFolder = `-- name: ClearFavoriteFolder :exec
UPDATE favorites SET folder_id = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) ClearFavoriteFolder(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, ClearFavoriteFolder, id)
	return err
}

const ClearFavoriteShortcut = `-- name: ClearFavoriteShortcut :exec
UPDATE favorites SET shortcut_key = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) ClearFavoriteShortcut(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, ClearFavoriteShortcut, id)
	return err
}

const ClearShortcutFromOthers = `-- name: ClearShortcutFromOthers :exec
UPDATE favorites SET shortcut_key = NULL WHERE shortcut_key = ?
`

func (q *Queries) ClearShortcutFromOthers(ctx context.Context, shortcutKey sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, ClearShortcutFromOthers, shortcutKey)
	return err
}

const DeleteHistoryByDomain = `-- name: DeleteHistoryByDomain :exec
DELETE FROM history WHERE url LIKE '%://' || ? || '/%' OR url LIKE '%://' || ? || '?%' OR url LIKE '%://' || ? || '#%' OR url LIKE '%://' || ?
`

func (q *Queries) DeleteHistoryByDomain(ctx context.Context, column1 sql.NullString, column2 sql.NullString, column3 sql.NullString, column4 sql.NullString) error {
	_, err := q.db.ExecContext(ctx, DeleteHistoryByDomain,
		column1,
		column2,
		column3,
		column4,
	)
	return err
}

const DeleteHistoryLastDay = `-- name: DeleteHistoryLastDay :exec
DELETE FROM history WHERE last_visited >= datetime('now', '-1 day')
`

func (q *Queries) DeleteHistoryLastDay(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, DeleteHistoryLastDay)
	return err
}

const DeleteHistoryLastHour = `-- name: DeleteHistoryLastHour :exec
DELETE FROM history WHERE last_visited >= datetime('now', '-1 hour')
`

func (q *Queries) DeleteHistoryLastHour(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, DeleteHistoryLastHour)
	return err
}

const DeleteHistoryLastMonth = `-- name: DeleteHistoryLastMonth :exec
DELETE FROM history WHERE last_visited >= datetime('now', '-30 days')
`

func (q *Queries) DeleteHistoryLastMonth(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, DeleteHistoryLastMonth)
	return err
}

const DeleteHistoryLastWeek = `-- name: DeleteHistoryLastWeek :exec
DELETE FROM history WHERE last_visited >= datetime('now', '-7 days')
`

func (q *Queries) DeleteHistoryLastWeek(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, DeleteHistoryLastWeek)
	return err
}

const DeleteHistoryOlderThan = `-- name: DeleteHistoryOlderThan :exec
DELETE FROM history WHERE last_visited < datetime('now', '-' || CAST(? AS TEXT) || ' days')
`

func (q *Queries) DeleteHistoryOlderThan(ctx context.Context, dollar_1 string) error {
	_, err := q.db.ExecContext(ctx, DeleteHistoryOlderThan, dollar_1)
	return err
}

const GetDailyVisitCount = `-- name: GetDailyVisitCount :many
SELECT date(last_visited) as day, COUNT(*) as entries, SUM(visit_count) as visits FROM history WHERE last_visited >= date('now', ?) GROUP BY day ORDER BY day ASC
`

type GetDailyVisitCountRow struct {
	Day     interface{}     `json:"day"`
	Entries int64           `json:"entries"`
	Visits  sql.NullFloat64 `json:"visits"`
}

func (q *Queries) GetDailyVisitCount(ctx context.Context, date interface{}) ([]GetDailyVisitCountRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDailyVisitCount, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyVisitCountRow{}
	for rows.Next() {
		var i GetDailyVisitCountRow
		if err := rows.Scan(&i.Day, &i.Entries, &i.Visits); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDomainStats = `-- name: GetDomainStats :many
SELECT SUBSTR(SUBSTR(url, INSTR(url, '://') + 3), 1, CASE WHEN INSTR(SUBSTR(url, INSTR(url, '://') + 3), '/') > 0 THEN INSTR(SUBSTR(url, INSTR(url, '://') + 3), '/') - 1 ELSE LENGTH(SUBSTR(url, INSTR(url, '://') + 3)) END) as domain, COUNT(*) as page_count, SUM(visit_count) as total_visits, MAX(last_visited) as last_visit FROM history GROUP BY domain ORDER BY total_visits DESC LIMIT ?
`

type GetDomainStatsRow struct {
	Domain      string          `json:"domain"`
	PageCount   int64           `json:"page_count"`
	TotalVisits sql.NullFloat64 `json:"total_visits"`
	LastVisit   interface{}     `json:"last_visit"`
}

func (q *Queries) GetDomainStats(ctx context.Context, limit int64) ([]GetDomainStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDomainStats, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDomainStatsRow{}
	for rows.Next() {
		var i GetDomainStatsRow
		if err := rows.Scan(
			&i.Domain,
			&i.PageCount,
			&i.TotalVisits,
			&i.LastVisit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFavoriteByShortcut = `-- name: GetFavoriteByShortcut :one
SELECT id, url, title, favicon_url, position, created_at, updated_at, folder_id, shortcut_key FROM favorites WHERE shortcut_key = ? LIMIT 1
`

func (q *Queries) GetFavoriteByShortcut(ctx context.Context, shortcutKey sql.NullInt64) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, GetFavoriteByShortcut, shortcutKey)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.FaviconUrl,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FolderID,
		&i.ShortcutKey,
	)
	return i, err
}

const GetHistoryByDateRange = `-- name: GetHistoryByDateRange :many
SELECT id, url, title, visit_count, last_visited, created_at, favicon_url FROM history WHERE last_visited >= ? AND last_visited < ? ORDER BY last_visited DESC
`

func (q *Queries) GetHistoryByDateRange(ctx context.Context, lastVisited sql.NullTime, lastVisited_2 sql.NullTime) ([]History, error) {
	rows, err := q.db.QueryContext(ctx, GetHistoryByDateRange, lastVisited, lastVisited_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.VisitCount,
			&i.LastVisited,
			&i.CreatedAt,
			&i.FaviconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetHistoryDates = `-- name: GetHistoryDates :many
SELECT DISTINCT date(last_visited) as visit_date FROM history ORDER BY visit_date DESC LIMIT ?
`

func (q *Queries) GetHistoryDates(ctx context.Context, limit int64) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, GetHistoryDates, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var visit_date interface{}
		if err := rows.Scan(&visit_date); err != nil {
			return nil, err
		}
		items = append(items, visit_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetHistoryStats = `-- name: GetHistoryStats :one
SELECT COUNT(*) as total_entries, SUM(visit_count) as total_visits, COUNT(DISTINCT date(last_visited)) as unique_days FROM history
`

type GetHistoryStatsRow struct {
	TotalEntries int64           `json:"total_entries"`
	TotalVisits  sql.NullFloat64 `json:"total_visits"`
	UniqueDays   int64           `json:"unique_days"`
}

func (q *Queries) GetHistoryStats(ctx context.Context) (GetHistoryStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetHistoryStats)
	var i GetHistoryStatsRow
	err := row.Scan(&i.TotalEntries, &i.TotalVisits, &i.UniqueDays)
	return i, err
}

const GetHistoryTimeline = `-- name: GetHistoryTimeline :many

SELECT h.id, h.url, h.title, h.visit_count, h.last_visited, h.created_at, h.favicon_url, date(h.last_visited) as visit_date FROM history h ORDER BY h.last_visited DESC LIMIT ? OFFSET ?
`

type GetHistoryTimelineRow struct {
	ID          int64          `json:"id"`
	Url         string         `json:"url"`
	Title       sql.NullString `json:"title"`
	VisitCount  sql.NullInt64  `json:"visit_count"`
	LastVisited sql.NullTime   `json:"last_visited"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	FaviconUrl  sql.NullString `json:"favicon_url"`
	VisitDate   interface{}    `json:"visit_date"`
}

// Extended history queries: timeline, analytics, cleanup
// NOTE: FTS5 search uses raw SQL in Go - sqlc doesn't support "table MATCH ?" syntax
func (q *Queries) GetHistoryTimeline(ctx context.Context, limit int64, offset int64) ([]GetHistoryTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, GetHistoryTimeline, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHistoryTimelineRow{}
	for rows.Next() {
		var i GetHistoryTimelineRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.VisitCount,
			&i.LastVisited,
			&i.CreatedAt,
			&i.FaviconUrl,
			&i.VisitDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetHourlyDistribution = `-- name: GetHourlyDistribution :many
SELECT CAST(strftime('%H', last_visited) AS INTEGER) as hour, COUNT(*) as visit_count FROM history GROUP BY hour ORDER BY hour
`

type GetHourlyDistributionRow struct {
	Hour       int64 `json:"hour"`
	VisitCount int64 `json:"visit_count"`
}

func (q *Queries) GetHourlyDistribution(ctx context.Context) ([]GetHourlyDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, GetHourlyDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHourlyDistributionRow{}
	for rows.Next() {
		var i GetHourlyDistributionRow
		if err := rows.Scan(&i.Hour, &i.VisitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetFavoriteFolder = `-- name: SetFavoriteFolder :exec
UPDATE favorites SET folder_id = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) SetFavoriteFolder(ctx context.Context, folderID sql.NullInt64, iD int64) error {
	_, err := q.db.ExecContext(ctx, SetFavoriteFolder, folderID, iD)
	return err
}

const SetFavoriteShortcut = `-- name: SetFavoriteShortcut :exec
UPDATE favorites SET shortcut_key = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) SetFavoriteShortcut(ctx context.Context, shortcutKey sql.NullInt64, iD int64) error {
	_, err := q.db.ExecContext(ctx, SetFavoriteShortcut, shortcutKey, iD)
	return err
}

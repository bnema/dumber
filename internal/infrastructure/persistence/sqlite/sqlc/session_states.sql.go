// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: session_states.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const DeleteSessionState = `-- name: DeleteSessionState :exec
DELETE FROM session_states WHERE session_id = ?
`

func (q *Queries) DeleteSessionState(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, DeleteSessionState, sessionID)
	return err
}

const GetAllSessionStates = `-- name: GetAllSessionStates :many
SELECT session_id, state_json, version, tab_count, pane_count, updated_at
FROM session_states
ORDER BY updated_at DESC
`

func (q *Queries) GetAllSessionStates(ctx context.Context) ([]SessionState, error) {
	rows, err := q.db.QueryContext(ctx, GetAllSessionStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionState{}
	for rows.Next() {
		var i SessionState
		if err := rows.Scan(
			&i.SessionID,
			&i.StateJson,
			&i.Version,
			&i.TabCount,
			&i.PaneCount,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSessionState = `-- name: GetSessionState :one
SELECT session_id, state_json, version, tab_count, pane_count, updated_at
FROM session_states
WHERE session_id = ?
`

func (q *Queries) GetSessionState(ctx context.Context, sessionID string) (SessionState, error) {
	row := q.db.QueryRowContext(ctx, GetSessionState, sessionID)
	var i SessionState
	err := row.Scan(
		&i.SessionID,
		&i.StateJson,
		&i.Version,
		&i.TabCount,
		&i.PaneCount,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSessionsWithState = `-- name: GetSessionsWithState :many
SELECT 
    s.id, s.type, s.started_at, s.ended_at,
    ss.state_json, ss.tab_count, ss.pane_count, ss.updated_at as state_updated_at
FROM sessions s
LEFT JOIN session_states ss ON s.id = ss.session_id
WHERE s.type = 'browser'
ORDER BY s.started_at DESC
LIMIT ?
`

type GetSessionsWithStateRow struct {
	ID             string         `json:"id"`
	Type           string         `json:"type"`
	StartedAt      time.Time      `json:"started_at"`
	EndedAt        sql.NullTime   `json:"ended_at"`
	StateJson      sql.NullString `json:"state_json"`
	TabCount       sql.NullInt64  `json:"tab_count"`
	PaneCount      sql.NullInt64  `json:"pane_count"`
	StateUpdatedAt sql.NullTime   `json:"state_updated_at"`
}

func (q *Queries) GetSessionsWithState(ctx context.Context, limit int64) ([]GetSessionsWithStateRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSessionsWithState, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsWithStateRow{}
	for rows.Next() {
		var i GetSessionsWithStateRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.StartedAt,
			&i.EndedAt,
			&i.StateJson,
			&i.TabCount,
			&i.PaneCount,
			&i.StateUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertSessionState = `-- name: UpsertSessionState :exec
INSERT INTO session_states (session_id, state_json, version, tab_count, pane_count, updated_at)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(session_id) DO UPDATE SET
    state_json = excluded.state_json,
    version = excluded.version,
    tab_count = excluded.tab_count,
    pane_count = excluded.pane_count,
    updated_at = excluded.updated_at
`

type UpsertSessionStateParams struct {
	SessionID string    `json:"session_id"`
	StateJson string    `json:"state_json"`
	Version   int64     `json:"version"`
	TabCount  int64     `json:"tab_count"`
	PaneCount int64     `json:"pane_count"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpsertSessionState(ctx context.Context, arg UpsertSessionStateParams) error {
	_, err := q.db.ExecContext(ctx, UpsertSessionState,
		arg.SessionID,
		arg.StateJson,
		arg.Version,
		arg.TabCount,
		arg.PaneCount,
		arg.UpdatedAt,
	)
	return err
}
